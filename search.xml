<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Mybatis/iBatis]]></title>
    <url>%2F2019%2F06%2F30%2FMyBatis%2F</url>
    <content type="text"><![CDATA[Mybatis简介 作用：封装了JDBC操作，简化了数据访问代码 封装的功能如下： 封装了获取连接，sql语句执行，释放连接 封装了sql参数设置（相比于jdbctemplate的sql语句，它的设置方式更方便，比如template.update(sql,objct[]) 这里需要传入一个object数组，而mybatis更方便,他只要在update()里传入一个对象参数，然后sql语句写上类似于 insert into emp(name,age) values(#{name},#{age})） 封装了记录映射成实体对象（封装了rowmapper）实体类属性名与查询结果集ResultSet中列名（有查询的别名话，以别名为主）保持一致 主要结构 如何去写Mybatis？ 详细看textmybaits 配置文件引入Jar 设置好sqlMapConfig.xml当中的数据库参数和含有sql语句的xml文件 引入mybatis.jar 和数据库jar包 编写与表中的数据字段名相同属性的实体类（这里根据的是db当中的emp表） 编写sql.xml文件 的那几个&lt;标签&gt; 以及标签里面的参数 有无参数和返回值 ，以及标签里的内容涉及到参数 #{id}(当传入的是基本类型时，#{}里的内容可以随意写,当传入的是对象的时候，#{}里的内容为对象的属性名称，当传入的是map时,这里传入的map是有要求的，它的泛型的第一个类型必须是string类型的，并且传map里面的第一个数据组里面的第一个string类型的数据必须为表当中的字段名。#{}里写的就是那个字段名) ,传多个参数就用对象封装，传的不是很多就用map封装详细看这里 返回数据类型 实体对象 属性名与字段名一致，使用resluttype 属性名与字段名不一致，给字段使用别名 map集合 以字段名当key,以字段值当value 编写 测试类 注意session那几个方法 （selectlist 和selectone 的区别）还有就是session记得commit 和close Mapper映射器接口规则 含义：就是将sqlmapper.xml文件当中的方法映射成一个dao类 映射器规则： 根据sql定义的id属性当接口方法名 根据sql定义的parameterType类型当方法参数类型 根据sql定义的resultType类型定义方法返回类型（多行（sql语句查询的行数）使用list&lt;resultType类型&gt;接收方法返回值；单行使用resultType类型接收方法返回值） 将sql定义文件中的namespace属性指定成包名.接口名&lt;mapper namespace=&quot;com.zac.empdao&quot;/&gt; 如何去写？ 先根据含有sql语句的xml文件写好dao的抽象类含sql语句的xml文件 ,dao类 然后在main方法当中通过session.getmapper()获取dao对象 Spring+Mybatis 主要要引入mybatis-spring.jar整合包 该包的作用：1.含有mapperFactoryBean组件，封装了根据Mapper映射器接口生成实现组件的功能 2.含有SqlSessionFactoryBean组件，封装了创建sqlsessionFactory过程3.含有MapperScannerConfigurer组件：封装了批量生成MapperFactoryBean组件的功能 大白话就是：将session.getMapper(costdao.class)那块内容封装成组件(costdao是以参数的形式传入进组件)到applicationContext.xml文件中 ,然后再通过ac.getbean(“beanid”)得到dao对象 如何实现spring+mybaits 引入jar包。dao(jdbc),aop,ioc,dbcp,mybatis,mybatis-spring.jar,数据库jar包， 方式一：编写applicationContex.xml图示，通过mapperFactorybean生成单个dao 在main方法当中获取dao对象然后调用图示 方式二：编写applicationContex.xml图示，通过mapperScannerfigurer批量生成dao,注意里面的注解属性如何去用,这样的话容器就只会将哪些含有注解的类实现dao注解定义在类上注解类定义1,注解类定义2 在main方法当中获取dao对象然后调用图示 spring+mybaits流程图]]></content>
      <categories>
        <category>学习-javaweb</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring与jdbc整合的应用]]></title>
    <url>%2F2019%2F06%2F28%2Fspring%E4%B8%8Ejdbc%E6%95%B4%E5%90%88%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Spring与jdbc整合的应用 详细看p11 提供了编写Dao的工具类 JDBCTemplate JdbcTemplate.update(“insert into…”,参数) 在hibernate中，使用hibernateTemplate 提供了AOP式事务管理 1.不需要在方法中追加事务提交和回滚 提供了统一的异常处理 DataAccessException无论你使用的是jdbc，还是herbinate,jpa还是啥的技术。他们几个抛出的异常都为DataAccessException的子类异常 Spring整合jdbc步骤 引入spring(ioc,aop,jdbc)开发包，添加src/applicationContext.xml文件，和数据库驱动,dbcp驱动包 编写实体类 编写DAO组件 在applicationContext.xml中扫描EmpDAO,注入jdbcTemplate对象 导入dbcpjar包，创建连接池对象 配置jdbcTemplate,在它的中注入dataSource连接池对象， Template查询和rowmapper 详细看 springjdbc01 在使用jdbc查询的时候使用template会出现rowmappertemplate.query(sql, rowmapper)所以就要使用到rowmapper rowmapper:sping中的RowMapper可以将数据中的每一行数据封装成用户定义的类. rowmapper的使用 定义一个类实现rowmapper接口 在Dao类当中功能方法,注意区分query()和queryforobject() 另外，值得注意：从数据库当中查询出来的一张表对应一个rowmapper和一个实体对象，如果我们通过关联查询查出来的多条字段，那么就得设计一个实体类，其中包括了这些字段，然后再用rowmapper去封装数据 如果sql语句写的是这个select count(*) from emp 它返回的是一个值 我们就可以直接使用template.queryforint()所以说 template.query() 返回的是list集合template.queryforonject() 返回的是一个对象template.queryforint() 返回的是一个值 springmvc和jdbc的小案例 详细看spingmvcjdbc02 案例流程：就是通过web的形式浏览器向服务器发送请求，然后服务器通过请求将数据库中的数据将数据以表的形式展现给用户 注意知识点1： 这样以接口的形式注入有利于降低程序的耦合度，因为到时候我们有可能要换EMPDAO底层的实现（不用jdbctemplate而用herbinateTemplate） 注意知识点2： 关于&lt;bean class=&quot;viewreslover&quot;&gt;设置问题对照视频中所讲的 这里业务方法返回给viewResovler的字符串是这样 同样如果在其他业务方法当中返回的其他路径下的jsp文件，那么问题就来了 所以就这么设置&lt;bean class=&quot;viewreslover&quot;&gt; preffix那设置的 / 表示的就是webRoot目录，因为controller组件本身就是servlet的一部分，之前讲过业务方法里的modelandview put方法就是绑定数据转发的形式，以及在viewResovler里设置preffix / 就对照着servlet 之前servlet里的路径问题：转发的绝对路径写在应用名之后。 还得明白 /fee/fee_list.jsp的含义 因为servlet的目录是webroot,和fee是在同一级，所以想要找fee文件下的fee_list.jsp文件就直接写fee/fee_list.jsp并且在前面加上/ 所以，懂了码？ 注意知识点3： 分页查询 设计dao 设计controller 设计jsp超链接]]></content>
      <categories>
        <category>学习-java框架学习</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于之前学习的代码workspace路径]]></title>
    <url>%2F2019%2F06%2F23%2F%E5%85%B3%E4%BA%8E%E4%B9%8B%E5%89%8D%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%BB%A3%E7%A0%81workspace%E8%B7%AF%E5%BE%84%2F</url>
    <content type="text"><![CDATA[关于之前学习的代码workspace路径我放在了c/user/wc/workspace里]]></content>
      <categories>
        <category>workspace路径</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring Web Mvc]]></title>
    <url>%2F2019%2F06%2F23%2Fspringwebmvc%2F</url>
    <content type="text"><![CDATA[什么是 spring web mvc ? 用于开发mvc结构的web程序，需要使用到ioc功能。详细看p5 3：00：00 MVC思想 将程序组件分为模型，视图，控制器三部分。 spring web mvc 处理流程 黑色字体部分是我们需要写的 spring web mvc小案例 流程 /hello.do –&gt; spring web mvc –&gt; /WEB-INF/hello.jsp/hello.do–&gt;DispatcherServlet(配置)–&gt;HanlderMapping（配置）–&gt;helloController（配置+编写）–&gt;ViewResolver（配置）–&gt;/WEB-INF/hello.jsp（编写） 具体操作,详细看传智springmvc01 搭建spring web mvc 开发环境 引入 ioc,mvc的jar包 src下添加applicationContext.xml 编写HelloController实现 规则：实现controller接口 配置DispatcherServlet 配置web.xml配置 那么为什么要在web.xml当中配置DispatcherServlet的同时还要加上applicationContext.xml初始化参数？那是因为这样做会使得两个文件相关联，applicationContext.xml中可以定义Handlermapping,controller,viewsolver.当请求过来了服务器会创建DispatcherServlet对象，这样这个对象就可以通过applicationContext.xml当中的组件了 配置applicationContext.xml当中的组件 通过注解配置applicationContext.xml 对于hadlemapping 详细看p7 传智spingmvc04 使用RequestMappingHanlderMapping组件@RequestMapping(&quot;/login.do&quot;)该标记写在controller业务方法前或者是业务类前 并且在applicationContext.xml文件当中写上&lt;mvc:annotation-driven/&gt;就可以直接省去以往的handlemapping的bean标签这里在业务类和业务方法前头加上了@requestMapping()：表示发送的请求地址为WebRoot/cost/list.do,在业务类前面加上@requestMapping()要注意。带斜杠是相对于根路径 的路径，不带是相对于父路径 的路径 对于Controller 取消了实现Controller接口及方法约定,可以允许程序员按照需要灵活定义业务方法如：public ModelAndView或者String 方法名(根据参数定义需要传入参数，request,session,response){} 定义返回值为string的话就意味着这个controller虽然只会返回viewName(视图名字)，springmvc底层还是会将返回的字符串封装到modelandview对象中传给viewreslover 但是这样使用的条件：Controller需要扫描到Spring容器，而且必须使用@Controller组件标注类 通过注解的方式处理多个请求（小案例） 详细看传智springmvc05 Controller如何接收请求参数 利用HttpServletRequest 利用业务方法参数 参数名与请求参数ky保持一致 参数名和请求参数不一致在方法参数那写上@RequestParam(&quot;key&quot;) 利用实体对象当方法参数 第三条的出现，就是为了解决将来会出现的很多个参数传入的情况,容器会自动依据User类里头有没有与传入参数相同名字的属性而传入不传入User类实例。 - 使用建议：后面两种方式都要注意，必须得保证请求传来的参数必须为String类型的 Controller如何向响应jsp传值 利用HttpServletRequest 利用ModelAndView做返回值 利用ModelMap方法参数详细看springmvc05 logincontroller.java Controller如何获取并使用session对象？ 直接从controller自定义方法参数中request的方法获取。 在controller自定义方法参数添加一个hpptSession 参数。 springmvc工作流程 浏览器发出http请求到dispatcherSevlet主控制器 主控制器会调用handlemapping组件依据的是请求和controller的映射关系 执行controller方法然后将返回结果给viewReslover. viewResolver会依据返回结果去找jsp，将模型数据给jsp jsp生成响应结果，给浏览器显示 解决springmvc项目当中中文接受乱码的问题 出现乱码的两种可能 对于第一种乱码产生的原因&amp;解决方法 产生原因：数据提交过来还是存在request对象当中，但是如果在不指明编码格式的情况下，服务器会按照ios8的编码格式来操作，springmvc框架只是封装底层的这些操作，这样默认还是按照ios编码操作 解决办法1：在项目前面加上过滤器Filter 解决办法2：在项目的web.xml文件前面加上过滤器配置（springmvc自带的类包） 对于第二种乱码的问题详细看Servelt文章 springmvc项目中如何处理异常 一般都是controller当中的方法出错了 全局异常处理方式第一种 在applicationContext.xml文件当中添加springmvc自带的异常处理标签（全局异常处理） 详细看传智rekone springmvc异常处理的过程 当执行到第三步的时候controller抛出异常，抛给hadlemapping，然后再抛给dispatcherservlet，然后dispatcherservlet会看applicationContext.xml文件当中是否有处理Controller异常的标签，有的话就会依据异常标签当中的&lt;prop key=&quot;异常类型&quot;&gt;/WEB-INF路径下的错误处理页面名字&lt;/prop&gt;抛给viewreslover去找异常处理jsp页面 局部异常处理方式 在controller文件当中加一个局部异常处理 只需要在controller当中再定义一个方法，头上加一个ExceptionHandler 只要异常被这个局部异常处理了，容器就不会调用全局异常 全局异常处理方式第二种方式 写一个类实现HandlerExceptionResolver，然后将信息写入到文件当中，然后再到applicationContext.xml配置一个标签 详细图示 如何实现登陆权限检查 使用session进行约定值判断 实现方法： 使用filter过滤器进行拦截，操作判断每一个.do的servlet当中有没有session所绑定的数据 采用拦截器 拦截器：他是springmvc当中特有的组件 拦截器作用：拦截器可以再controller之前拦截，也可以在controller之后拦截；也可以在jsp解析完毕给浏览器输出之前拦截。 使用格式： 编写一个类实现HandlerInterceptor接口，在每重载的方法里实现相应的逻辑 配置applicationContext.xml文件 显示效果- ![9642](https://s2.ax1x.com/2019/06/28/ZKt2bq.png)]]></content>
      <categories>
        <category>学习-java框架学习</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring简介入门&SpringIOC]]></title>
    <url>%2F2019%2F06%2F21%2FSpring%26SpringIoc%2F</url>
    <content type="text"><![CDATA[关于框架学习 框架有什么用？能帮我们做什么？ 帮我们做了哪些事？需要我们配合做哪些事？ 熟悉框架的设计思想，至于如何实现，以后再去考虑 练习时，多练习即便，掌握开发主要步骤 spring框架 spring框架作用 spring core(ioc功能) spring Aop功能 总体作用来说，就是管理组件对象，维护对象关系，目的：降低组件之间的耦合度 （ 传统的web程序请求过程： 请求–&gt;Servlet–&gt;service–&gt;多个Dao–&gt;jsp 现在用spring框架来做的话，就直接用spring框架来做前三步） Spring Web MVC功能(MVC涉及，目的：架构一个mvc结构的web程序) spring整合其他技术（spring如何和structs技术，jdbc,mybaits，hibernate等技术整合在一起 在spring中使用整合API编程：spring–&gt;整合API–&gt;调用原有技术API） spring框架概述spingIOC应用 概念&amp;作用： IOC概念：Inversion of Control控制反转后反向控制：改变了对象获取方式，之前编码方式采用new构造器方式获取对象;ioc中采用由容器创建对象之后注入进来使用。只要修改配置就可以修改对象关系。 详细看p2 3:00:00 管理对象 管理对象包含：对象的创建，初始化，释放资源,销毁 维护对象关系 如何去使用spring管理对象的创建bean的创建 搭建springioc开发环境 引入相关jar包 在src添加applicationContext.xml 在applicationContext.xml文件当中配置相关的组件这里拿bean举例 其实使用框架无非就是将在项目当中要用到的组件配置到applicationContext.xml文件当中，当我们在项目当中要用到这些组件所对应的对象的时候，直接向applicationContext中去获取（省时间） 配置方式1 通过构造方法该组件对象是通过之接new来创建的 &lt;bean id=&quot;c&quot; class=&quot;java.util.GregorianCalendar&quot;&gt;&lt;/bean&gt; 配置方式2 通过静态工厂方法组件对象是通过类的静态方法获取的 配置方式3 通过对象工厂方法 组件对象是通过另外一个对象的方法来获取的 &lt;bean id=&quot;date&quot; factory-bean=&quot;c1&quot; factory-method=&quot;getTime&quot;&gt;&lt;/bean&gt; 编写一个类包含main方法 运行结果 使用spring容器的图解 管理对象 ,如何通过spring去管理对象的初始化，释放资源,销毁。 对象创建的方式单例，非单例 spring创建bean对象的控制 控制对象的创建方式（使用范围）就是单例和非单例 在元素中使用scope属性控制，scope可以支持sigleton(单例)prototype(非单例) 默认值是singleton &lt;bean scope=&quot;singleton&quot;&gt;表示该组件在spring容器里面只有一个bean对象，表示该组件每次ac.getBean(“id”)都会返回同一个对象。比如dao就用这种方式来定义 结果为true &lt;bean scope=&quot;prototype&quot;&gt;表示该组件每次ac.getBean(“id”)都会返回一个新的对象。 结果为false 如果在applicationContext.xml文件中的一个组件所对应的那个组件类的结构如下所示，那么这个组件的scope属性必须为prototype public class xx{ private User u; public void xxx{ xxx方法对本类的属性进行了操作 } } 指定对象初始化方法 init-method方法的使用 利用元素的init-method指定。当创建对象后，自动执行Init-method方法 其实我们也可以直接在对象创建的时候通过类构造器初始化 图解 指定对象销毁（一般都用在单利模式类当中用到了很多集合，比如流，这个方法里面就可以写流的资源释放操作） 利用元素的destory-method指定。 满足以下条件该方法才有效。 组件对象为单例模式 调用AbstractApplicationContext容器对象的close()方法 图解 控制单例对象创建时机 在默认情况下，单例对象是spring容器创建时实例化；可以使用元素的lazy-init=true属相将创建时机推迟到getBean()方法时调用只对单例模式有用。 图解 在不设置lazy-init的情况下等于lazy-init=false,单例组件会随着容器的创建而初始化结果的话，容器的创建时，该单利组件就初始化了。另外一种就不演示了， 当然我们也可以通过在根元素中设置所有的的的管理操作 维护对象关系 采用注入方式建立对象关系。Dependency Injexttion DI依赖注入 依赖注入分类 set注入方法注入 创建方式 编写类 这个类当中必须有属性所对应的set方法 applicationContext.xml配置 值得注意的是配置文件当中当中的name属性的值必须和定义的那个类中的属性相同名 编写main方法调试 在main方法里面比较两种为属性赋值的方式，可见传入参数和组件对象的耦合性是有多么的低，当我们需要修改传入的参数时只需要修改xml文件 测试结果 构造注入 创建方式 编写类 配置xml文件 main方法调试 测试结果 依赖注入的小案例 图解 编写student类 配置xml文件 注意ref属性的使用 main 测试结果 装配注入 这种注入方式也是set注入的方式 格式 用于指定自动注入规则，属性可以使用byType,byName,constructor等，用于简化注入配置 byType会依据容器当中的符合set()参数类型的组件添加到被注入组件中列举上面的例子的student,phone，computer的关系。使用byType类型匹配注入需要注意，有两个及以上匹配会出异常。 byName则依据容器当中符合名字的组件对象注入组件中 各种类型信息的注入配置 注入字符串，数值单个数值 注入bean对象 注入集合list,set，map，properties spring表达式注入 Spring表达式的用途： 如果想要在一个组件当中set注入时：使用另外一个组件或者是util:properties/Map组件当中的属性的话，就得用到它。 格式 #{beanID.属性/key} 注意事项： 如果注入的是采用beanID.属性的形式，那么那个Bean当中的那个属性必须得有所对应的get（） 注意的事项- date注入在构造方法那里转化![8854](https://s2.ax1x.com/2019/06/28/ZM5C7t.png) 注入list 注入空值 注入list list中的元素 为person对象 map注入 properties注入 集合的外部定义 propertiest外部定义并且是通过外部读取的方式 当采用spring表达式注入的时候想用list/set中的值来注入 详细看spring03 通过注解配置应用ioc（配置xml文件） 如果一个项目当中有好几千个组件需要配置在xml文件当中，那岂不是写死你？所以就出现了这项技术代替手写 详细看p4 01:37:25 spring04 组件自动扫描 注解：在类定义，方法定义，成员变量定义前面使用，格式为@注解标记名 他可以按照指定的包路径，将包下所有组件扫描，如果发现组件类定义前有以下标记，会将组件扫描到spring容器。 @Component 其他组件 @Controller 控制层组件 @Service 业务层组件 @Respository 数据访问层组件Dao @Named(需要引入第三方标准包) @Scope 控制对象的单例和非单例 @postconstruct 指定init-method @predestory 指定 destory-method 要注意的就是如果在类名前面使用了组件自动扫描如@Component那么这个组件在ioc容器当中的id名字就为该类首字母小写的类名，当然我们也可以指定@Component(&quot;aa&quot;) 注解注入 @Resource //默认按名称注入 如果找不着 就按照类型注入 @Autowired 等价于第一种 都可以实现注入。如果不存在多个匹配类型，使用@Resource和@Autowired都可以。如果存在多个匹配类型，建议按照名称注入.格式:@Autowired @Qualifier(&quot;指定名称&quot;)和 @Resource(name=&quot;指定名称&quot;) 他俩都可以写在属性定义和Set方法定义前 spring表达式注入 :用来注入非对象类型的属性，一般这些属性值都是存储在properties（集合）当中.使用格式：在属性定义前加上@value(“spring表达式”)。 详细看spring04 通过注解的方式注入我们在组件类当中可以不用写属性的set方法 set注入建议用resource,构造器注入建议使用autowired]]></content>
      <categories>
        <category>学习-java框架学习</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX]]></title>
    <url>%2F2019%2F06%2F18%2FAJAX%2F</url>
    <content type="text"><![CDATA[AJAX ajax简介 Ayschronous JavaScript and XML(json格式)异步JavaScript和xml，ajax是属于客户端和服务端交互的一项技术 原有交互模式(整个页面刷新+请求和响应同步处理)：浏览器发送请求–&gt;tomcat服务器–&gt;tomcat将相应信息给浏览器–&gt;浏览器显示响应结果 ajax交互模式(局部刷新+异步处理)：浏览器发送请求–&gt;XMLhttpRequest发送–&gt;tomcat服务器–&gt;tomcat返回结果—&gt;xmlhttprequest接受结果–&gt;将结果显示在浏览器上 ajax的好处 具有局部刷新和异步处理的特性 提高了程序交互效率(传递数据量少) 提高用户的体验（避免的页面的频繁刷新） ajax技术 ajax技术是一系列技术的综合运用 它是基于js发请求和响应处理的 以XMLHttpRequest对象为核心 涉及html,css等渲染技术 涉及xml，json等数据交互格式 ajax小案例（详细看项目ajax） 这个案例实现目的，通过jsp当中的超链接获取servlet返回的数据并显示在jsp当中servlet import java.io.IOException; import java.io.PrintWriter; javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; public class text extends HttpServlet { public void service(HttpServletRequest request, HttpServletResponse response)throws ServletException, IOException { System.out.println(&quot;那个男人，它出现了！&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); out.print(&quot;文章：15663&quot;); } } 关于ajax的中文传值问题 只需要在jsp文件的Js代码中修改 关于ajax设置请求头的问题 关于提高用户友好性的代码 在发送请求对象之后对用户输入的数据进行检查 jquery当中使用ajax $.ajax() 详细看jq.jsp 这个函数将XMLHttpReqeust对象封装了 使用方式： $.ajax({url:&quot;地址&quot;,type:”get/post”,data:”(提交的数据){&quot;name&quot;:zac,&quot;age&quot;:18},sucess:（里面写回调函数）function(msg){....},async:默认为true,true表示异步处理dataType:预期服务器返回的数据类型 xml,html,script,json,error:失败回掉函数function(msg){....}，beforeSend:请求发送前回调函数`function(msg){….}}) $.get() 这个函数是基于$.ajax()函数的从这里可以看出$.ajax()函数是属于最底层的函数 格式：$.get(url,data,callback回掉函数,type服务器返回的数据类型xml，json) $.post() 它跟$.get()函数类似也是基于$.ajax()的 $.getJSON(url,data,callback) 在$.get()方法上进一步封装限制了返回的类型 $.getScipt(url,data,callback) 在$.get()方法上进一步封装限制了返回的类型 它的作用是：向服务器发送请求，要求返回的数据为js类型的。这种方法运用用于当页面的js脚本文件很大时，可以通过向服务器发送请求的形式进行加载页面。 $(“div”).load(“url”) 在$.get()方法上进一步封装了success回掉函数 这个语句的意思就是向url地址发送请求，将返回的数据显示在div里面 ajax当中json数据格式 含义 javaScript Object Notationjavascript对象类型格式 定义格式 1. var a = {key1:value1,key2:value2}//这里a就是一个json对象 获取值的方式 1. 取value1：`a.key1`。取value2:`a.key2` 在使用json的时候服务器往往会返回这样的数据 第一种：var v1 =[{name:”tom”,age:18},{name:”zac”,age:20}] 获取name:”zac”的方式：v1[1].name 第二种：var v2={name:”zac”,company:{job:engineer}} 获取”zac”在公司里面的职位： v2.company.job json小案例详见ajax_json textjson.html textjson.html 案例1 模拟服务端传过来json数据并显示在html上 html代码 效果 案例2 通过服务端传送json数据给客户端 html代码 服务端代码 记得复习ajax_joson textjson.html ajax教程还没看完啊 2：00：00]]></content>
      <categories>
        <category>学习-javaweb</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsp标签和el表达式]]></title>
    <url>%2F2019%2F06%2F15%2Fjsp%E6%A0%87%E7%AD%BE%E5%92%8Cel%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[jsp标签 什么是Jsp标签？ jsp标签用来替换jsp中的java代码，因为直接在jsp文件当中写java代码不方便Jsp文件维护（比如，将Jsp文件交给美工去修改就很不方便，所以sun公司就制定了jsp标签技术规范. 可以将jsp变迁看作是一个占位符，容器遇到jsp标签之后，会依据标签名找到标签类，然后调用标签类中的方法。 使用Jsp标签，有两个好处： jsp文件很好维护 方便代码的复用（可以将一些常见的代码封装成一个jsp标签） jstl(javaa standard tag lib java标准标签库) jstl 是什么？ apache开发的一套Jsp标签，后来捐献给了sun,sun将其命名为jstl。 怎么使用jstl? 将jstl相关的jar文件拷贝到WEB-INF\lib下。 如果使用javaee5.0就一般不用导包 使用taglib指令导入相应的标签 jstl当中几个核心的标签 if 格式&lt;c:if text=””&gt;标签体 在这里if就是一个表亲，需要介绍命名空间和前缀 命名空间：为了区分同名元素而设置的的一个字符串 而如果这个标签在jsp页面中就会有个对应的taglib标签&lt;%@taglib uri=”http://www.tarena.com.cn&quot; prefix=”c”%&gt; uri 就是命名空间 prefix就是前缀(别名) 当text属性值为true时，容器会执行标签体的内容。text属性可以使用el表达式来计算。 这里的话解释以下&lt;c:if&gt;标签的执行流程：当容器看到这个if标签的时候就会根据taglib标签当中指定的前缀和命名规范往jstl.jar中找到相应的标签类。将标签类实例化并执行里面的方法test那块的意思就是如果request当中绑定的user的gender为’f’的话就执行&lt;c:if&gt;当中的内容，显示为男，var和scope那块的话，意思就是将test的属性那块的el表达式的结果作为 request.setatrribute(‘flag’,’el表达式结果true/false’) 绑定起来。所以在判断性别不为’f’的时候，就直接再命名一个标签test的属性值就依据flag来确定 scope绑定的范围只能是page,application,session,application choose 格式 123456789101112 &lt;C:choose&gt; &lt;c:when test=&quot;&quot;&gt; &lt;/c:when&gt; &lt;c:otherwise&gt; &lt;/c:otherwise&gt; &lt;/c:choose&gt; ``` when可以出现一次或者多次，表示一个分支,当test为true时，执行该分支。otherwise可以出现0次或者1次，表示例外![356](https://s2.ax1x.com/2019/06/17/VbUXX4.png)![583](https://s2.ax1x.com/2019/06/17/Vba1gS.png) 3. forEach 1. 格式 ```&lt;c:forEach items=&quot;&quot; var=&quot;&quot; varStatus=&quot;&quot;&gt; &lt;/c:forEach&gt; 用来便利集合或者数组。 items属性：用来指定要遍历的集合或者数组，可以使用el表达式。 var属性：用来指定一个绑定名，绑定范围固定是pageContext. 注：没次从集合或者数组中取一个元素，然后将其绑定导pageContext上，绑定名由var属性来指定。 varStatus 用来指定一个绑定名，绑定范围固定是pageContext 绑定值是一个特殊的对象，该对象提供了一些方法，用来获得当前遍历的状态。 getIndex():获得当前被遍历的元素的下标（从0开始）。 getCount():获得当前是从第几次遍历(从1开始) forEach标签的示例详细看R中的emplist.jsp和update.jsp文件移除jsp文件当中的java代码 自定义标签 如何自定义标签？ 写一个Java类，继承SimpleTagSupport类(简单标签技术类)。 override doTag方法，在该方法里面 编写处理逻辑。 标签有哪些属性，标签类要有对应的属性 a.要求属性名一直 b.类型要匹配 c.这些属性要有对应的set方法 d.为什么需要set方法呢？ 详细看p25 1:33:18 这个自定义标签到底是怎么执行的？详细看P25 2:31:29 描述标签（.tld文件）*就是绑定标签和标签类的对应关系 * 注意： tld文件要放在WEB-INF\下。 的值可以是 empty:该标签没有标签体scriptless：可以有标签体，并且标签体的内容不能出现java代码（&lt;% %&gt;,&lt;%= %&gt;,&lt;%! %&gt;） JSP: 可以出现Java代码。但是，只有负载标签技术才支持改制，简单标签技术只支持empty和scriptless. el表达式 什么是el表达式？ 是一套简单的运算规则，用于给jsp标签的属性赋值，也可以直接输出 el表达式的使用 访问Bean的属性 javabean就是一个java类有属性以及获取该属性的方法 方式一： ${user.name} 如何执行的？ 容器依次会从pageContext,request,session,application中查找(通过调用getAtrribute()方法)绑定名称为”user”的对象，并且调用该对象的”getName()”方法，最后输出getName()方法的返回结果。 注意：1.el表达式会将获取为Null的值转化成空字符串输出2.如果找不到该对象，则会输出空字符串3.如果要制定查找范围，可以使用pageScope,requestScope,sessionScope,application来指定。 方式二 ${user[“name”]} 等价于方式一 注： []里面可以出现绑定名在下图中[str] 中 容器也会依次从pageContext,request,session,application中查找绑定名为str所对应的值 []里面可以出现从0开始的下表，用于访问数组中的某个元素 进行一些简单的运算, 运算的结果可以给jsp的标签的属性赋值，也可以直接输出。 算数运算 + - * / % 注：加号只能求和 关系运算 &gt;,&lt;,&lt;=,&gt;=,==,!= 逻辑运算 &amp;&amp; || ! empty运算 用来判断 集合是否为空 或者是否为一个空字符串，如果为空则返回true 格式： ${empty 想要查找的绑定名} 读取请求参数值(用的不多) 例如向jsp传入参数 e3.jsp?username=zac 格式 ${param.username}等价于request.getParameter(“username”) ${paramValues.username}等价于request.getParameterValues(“username”)]]></content>
      <categories>
        <category>学习-javaweb</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态管理]]></title>
    <url>%2F2019%2F06%2F10%2F%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[状态管理 什么是状态管理？ 将浏览器和web服务器之间的多次交互几位一个整体来处理，并且将多次交互所涉及的数据（即状态）保存下来 进行状态管理的方式有几种？ cookie(在客户端管理用户的状态) session（在服务段管理用户的状态） cookie 什么是cookie? 是服务器临时保存在浏览器端的少量的数据。 cookie的工作原理 当浏览器访问服务器时，服务器可以将少量数据以ser-cookie消息头的方式发送给浏览器，浏览器会将这些数据临时保存寄来。 当浏览器再次访问服务器时，会将之前保存的这些数据以cookie消息头的方式发送给服务器。 如何添加cookie? Cookie c = new Cookie(String name , String value); `response.addCookie(c);` cookie的读取Cookie[] rquest.getCookies() String Cookie.getName()//获取cookie名字 String cookie.getValue()//获取cookie的值 关于cookie添加和读取的编码问题 cookie只能保存合法的ascii字符，对于中文，需要将其转化成相应的ascii字符表示形式。 URLEncoder.encode(s,”utf-8”)URLDecoder.decode(s,”utf-8”)注：添加cookie时，建议最好统一编码处理 cookie的生存时间问题 缺省情况下，浏览器会把cookie保存在内存中，只要浏览器不关闭，cookie就会一直存在，浏览器关闭，cookie就会销毁。 setMaxAge(int second)注意：参数是秒 second &gt; 0 浏览器会将cookie保存在硬盘上，如果超过了指定的时间，则cookie会被删除 second &lt; 0 默认缺省值 second = 0 删除cookie 就是这样咯 怎么修改cookie? 服务器向浏览器再发送一个同名的cookie，那么原先浏览器中保留的cookie会被覆盖。 如何删除一个cookie? 在服务器端创建好一个和客户端同名的 cookie c = new cookie(“cart”,””);cookie名 设置该cookie的最大生存时间 c.setMaxAge(0) 向浏览器发送cookie response.addCookie(c) cookie的路径问题 什么是cookie的路径问题？ 浏览器再向服务器上的某个地址发送请求时，会比较该地址是否符合cookie的路径的要求，只有符合条件的cookie才能被发送出去 cookie的默认路径 等于添加该cookie的组件(servlet/jsp)的路径 匹配原则 请求地址必须等于cookie的路径，或是其子路径 cookie的限制 不安全，如果有名干数据必须以cookie的方式来保存，必须加密。 可以被用户禁止 cookie只能保存少量的数据(4k) 浏览器能保存的cookie的数量也有限(大概300个左右) 只能保存字符串 session(会话) 什么是session? 服务器端为维护状态而创建的一个特殊对象 工作原理 浏览器访问服务器时，服务器会创建一个session对象（该对象与一个唯一的id，称之为sessionid）,服务器会将sessionid以cookie的方式发送给浏览器，然后当浏览器再次访问服务器，会将sessionid以cookie的方式发送过来，服务器通过sessionid找到对应的session对象 如何获取session对象？ 方式1 HttpSessoin s = request.getSession(true/false); true:先查看请求当中有没有sessionid，如果没有，创建一个session对象。如果有sessionid,则依据sessionid查找对应的session对象。 false:先查看请求当中有没有sessionid，如果没有则返回null。如果有sessionid则会在服务器端查找session对象如果找不到session对象则会返回Null。 方式2 HttpSession s = request.getSession() 等价于方式1中的true情况request.getSession(true) session当中常用的方法 String getId() 获取sessionid setAttribute(String a ,object b) 绑定数据 用来设置session值的，sessionName是名称，object是你要保存的对象。 getAttribute(String a)该方法有可能返回null用来得到对应名称的session值，即得到object对象，注意需要进行类型转换！ removeAtrribute(String name) session超时 什么是session超时 服务器会将空闲时间过长的session对象删除掉 缺省的超时。时间 服务器缺省的时间限制一般是30分钟 设置超时时间的方法 session.setInActiveInterval(int seconds); session的删除 session对象.invalidate()]]></content>
      <categories>
        <category>学习-javaweb</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Filter和Listener的使用]]></title>
    <url>%2F2019%2F06%2F10%2FFilter%E5%92%8CListener%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Filter 什么是过滤器？ servlet规范当中定义的一种特殊的组件，用来拦截容器的调用过程。容器收到请求之后，通常情况下会调用servlet的service方法来处理请求。如果没有过滤器，则容器会先调用过滤器的方法 它的生命周期和servlet是一样的，过滤器和原来被过滤的servlet是共用一个request和resrponse对象的 如何写一个过滤器？ 写一个Java类，实现filter类 public class commentFilterA implements Filter {} 在doFilter方法里面，编写拦截处理逻辑 public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException {} 配置过滤器（web.xml）让容器知道哪些请求需要拦截 过滤器的优先级 当有多个过滤器对同一个servlet进行过滤的时候(都满足过滤的条件)容器会依据的先后顺序来调用 过滤器的初始化参数的使用 先在filter类中定义一个私有变量 在filter类中的init()方法中给config赋值 过滤器的优点 1.在不修改源程序的基础上，为程序增加一些新的功能 2.将多个组件相同的处理逻辑集卸载过滤器里面方便代码的维护 过滤器的相关代码 package web; import java.io.IOException; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; /* * 过滤器很类似于servlet * * 都是通过先通过构造器实例化，然后再通过init()进行初始化 */ public class commentFilterA implements Filter { private FilterConfig config; /* * 该类只要继承了Filter的话，当servlet被创建，该类就会被创建（类似于servlet当中添加了&lt;on-starup&gt;标签样的） * */ public commentFilterA(){} @Override public void destroy() {} /** * 容器通过dofilter方法来处理请求 dofilter和servlet当中的service方法用的是同一个request,response对象 * * ServletRequest 和ServletResponse 是HttpServletRequest和HttpServletResponse的父类 * 但是他俩是个过时的接口 所以在方法里需要强转； * * filterChain(过滤器链) * 如果调用了FilterChain的doFilter方法，则容器会继续往后调用。 */ public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2) throws IOException, ServletException { System.out.println(&quot;过滤器A的dofilter方法开始执行&quot;); HttpServletRequest request = (HttpServletRequest)arg0; HttpServletResponse response =(HttpServletResponse)arg1;**这里需要强转 因为过滤器和被过滤的servlet共用的是httpservletreqeust而不是servletrequest（他俩是子父关系）** request.setCharacterEncoding(&quot;utf-8&quot;); String s = request.getParameter(&quot;comment&quot;); if (s.indexOf(config.getInitParameter(&quot;illegalStr&quot;))!=-1) { //包含了敏感字 request.setAttribute(&quot;mingganzi&quot;, &quot;评论区出现了敏感字&quot;); request.getRequestDispatcher (&quot;sorry.jsp&quot;).forward(request, response); }else{ arg2.doFilter(arg0, arg1); } System.out.println(&quot;过滤器A的dofilter方法执行完成&quot;); } /** *这里的参数filterconfig就类似于 servletconfig *该方法只会执行一次 * */ public void init(FilterConfig arg0) throws ServletException { //将容器传过来的filterconfig保存下来 config = arg0; } } Listener 什么是监听器？(框架中用到) servlet规范当中定义的一种特殊的组件，用来监听容器(容器只能创建一次监听器)产生的事件 容器产生的事件主要有两大类 1)生命周期相关的事件容器创建了或者销毁了request,session,ServletContext(servlet上下文)时产生的事件 2) 绑定数据相关的事件 调用了request,session,servlet上下文的setAttribute,removeAtrribute时产生的事件 如何去写一个监听器？ 1.写一个java类，实现相应的监听器接口。 比如，要监听session的创建和销毁，就要实现HttpSessionListener接口 2.在接口方法当中实现监听处理逻辑 3.配置web.xml文件 servlet上下文 什么是servlet上下文？ 容器启动东后，会为每个web应用创建唯一的一个符合servletContext接口要求的对象 servlet上下文的又来 就是sun公司为了通过web应用调用servlet上下文对象来进一步调用了容器(tomcat)除了网络以外的其他服务（日志，安全，服务，权限）（但是这些服务都比较鸡肋，实际，不适用） servlet上下文特点 唯一性：一个web应用对应唯一的一个上下文。 持久性：只要容器没有关闭，并且应用没有被删除，则上下文一直存在。 如何获取上下文？ GnericServlet（直接在service方法中通过getServiceContext()来获取serviceContext对象）,ServletConfig,FilterConfig,HttpSession提供了一个getServletContext方法来获取上下文。 上下文的作用： （只要容器不关，任何servlet和filter数据就能访问那些绑定的数据）setAttribute(),getAttribute(),removeAtrribute(),将数据绑定到上下文，可以随时访问 同样 request session 同样都可以绑定数据 数据绑定的规则：在满足使用条件的情况下，优先使用生命周期短的（request&lt;session&lt;ServletContext上下文） request绑定的数据只能在同一个请求或转发所涉及的各个组件可以访问；session绑定的数据只有在同一个会话所涉及的组件可以访问；ServletContext上下文绑定的数据是同一个应用中的所有组件都可以访问的 访问全局的初始化参数 1.在web.xml文件中配置键值对 2.在servlet类当中获取servletContext然后通过方法getInitParameter(String name)获取全局初始化参数 application的使用 什么是application对象？ 当web服务器启动时，web服务器会自动会创建一个application对象，application对象一旦创建，他就一直存在，知道web服务器关闭 注意 一个web服务器通常有多个web服务目录(网站)，当web服务器启动时，它自动为每个web服务目录都创建一个对应的application对象，这些对象各自独立，而且和web服务器目录一一对应 application对象的生命周期 从web服务器启动，知道web服务器关闭 application对象的基类是：javax.servlet.ServletContext类。 所以我们可以直接获取servletcontext中的绑定的数据而不用去先获取servletcontext对象 application的常见方法 String getAttribute(String name) 根据属性名称获取属性值Enumeration getAttributeNames() 获取所有的属性名称。void setAttribute(String name, Object object) 设置属性，指定属性名称和属性值。void removeAttribute(String name) 根据属性名称删除对应的属性。String getContextPath() 获取当前Web应用程序的根目录String getContextPath() 获取当前Web应用程序的根目录。 request也有一个getContextPath() 相比之下更建议使用application的&lt;%=request.getContextPath()%&gt; 该方法的使用是为了解决相对路径的问题，可返回站点的根路径也就是webContent。 jsp当中上下文使用方法 详见jsp掌中的隐藏对象 关于web.xml文件的书写格式 一般在web.xml文件当中的顺序 1.全局初始化参数2.过滤器3.监听器4.servlet 打开地址(只需要写到应用名)后的首页 地址必须为 .jsp .html文件 session和监听器的小案例(测试一个web程序同时在线的人数)package web; import javax.servlet.ServletContext; import javax.servlet.http.HttpSession; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener; /** * 测试监听器 * @author wc * */ public class countListener implements HttpSessionListener { /** * 当session被创建时就会调用该方法 */ @Override public void sessionCreated(HttpSessionEvent arg0) { System.out.println(&quot;session 创建起来了...&quot;); //这里只能通过session获取servletContext //通过这个参数HttpSessionEvent arg0来获取被创建的seesion HttpSession s = arg0.getSession(); ServletContext sctx = s.getServletContext(); Integer count =(Integer) sctx.getAttribute(&quot;count&quot;); if (count==null) { count=1; } else{ count++; } sctx.setAttribute(&quot;count&quot;, count); } /** * 同样当session被删除就调用该方法 */ @Override public void sessionDestroyed(HttpSessionEvent arg0) { System.out.println(&quot;session 销毁了..&quot;); HttpSession s = arg0.getSession(); ServletContext sctx = s.getServletContext(); Integer count = (Integer)sctx.getAttribute(&quot;count&quot;); count--; sctx.setAttribute(&quot;count&quot;, count); } } &lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=utf-8&quot; pageEncoding=&quot;utf-8&quot;%&gt; &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; &lt;html&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;title&gt;测试用户在线的人数&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 当前在线的人数为：&lt;%=application.getAttribute(&quot;count&quot;) %&gt;&lt;a href=&quot;&lt;%=application.getContextPath() %&gt;/logout&quot;&gt;退出当前登陆&lt;/a&gt; &lt;% System.out.println(application.getAttribute(&quot;count&quot;)); %&gt; &lt;/body&gt; &lt;/html&gt; servlet线程安全问题 为什么servlet存在线程安全问题？ 容器在默认情况下只会创建一个Servlet实例 容器收到一个请求，就会启动一个线程来处理，如果有多个请求同时访问某个Servlet,就会导致多个线程调用同一个servlet实例，就有可能产生线程安全问题（如多个线程修改servlet的属性） 如何解决？ 使用synchonized对有可能产生线程安全问题的代码块枷锁加锁的话会影响性能]]></content>
      <categories>
        <category>学习-javaweb</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sevlet和Jsp相关的概念]]></title>
    <url>%2F2019%2F06%2F09%2FServlet%26Jsp%2F</url>
    <content type="text"><![CDATA[什么是servlet? 是sun公司制定的一种用来拓展web服务器功能 的 组件规范。 拓展web服务器功能的含义 web服务器只能处理静态的资源请求（即需要事先将html文件准备好),可以使用servlet来扩展（即web服务器可以通过servlet来处理动态资源的请求，比如访问数据库）。 组件规范的含义 什么是组件？ 符合一定规范，实现部分功能的，并且需要部署到响应的容器中才能运行的软件模块（所以说servlet是一个组件，需要部署到相应的servlet容器里面才能运行） 什么是容器？ 符合一定规范，提供组件的运行环境的程序（tomcat就是一个容器，提供了servlet的运行环境。基本上一个servlet容器就是一个微型服务器） 如何写一个servlet呢？ 写一个Java类 ，实现一个接口servlet 或者继承httpServlet抽象类(通常采用第一种) 编译 打包（变成组件） 创建一个具有如下结构的文件夹： appname(应用名) dangdang WEB-INF classes(放编译后的class文件) lib（可选的,放jar文件） web.xml(部署描述文件) 部署 将第三步创建好的整个文件夹拷贝到servlet容器相应的位置注：可以使用Jar命令将第三步创建好的文件夹压缩成一个“.war”为后缀的文件，然后拷贝 启动容器访问servlet http://ip:port/appname/url-pattern*注意：url-pattern在web.xml文件中定义* servlet是如何运行的？当用户向浏览器地址栏输入http://ip:port/helloweb/sayHello?name=zs 浏览器使用ip：port（端口号）连接服务器 浏览器将请求数据按照http协议打成一个数据包（请求数据包）发送给服务器请求数据包的内容包含了请求资源路径(/helloweb/sayHello?name=zs)，另外，在请求数据包当中，还会包含浏览器自动生成的一些信息。 服务器创建两个对象：请求对象（Request）和响应对象（Response）服务器解析请求数据包，将解析之后的数据存放到请求对象里面，方便servlet读取请求数据(因为servlet不用解析请求数据包，如果要解析，需要理解http协议)。请求对象是HttpServletRequest接口的一个实现。响应对象是HttpServletResponse接口的一个实现，响应对象由于存放servlet处理的结果。 依据请求资源路径找到相应的servlet配置，通过反射创建servlet实例(容器只会创建一个实例)。然后调用其service()方法。在调用service()方法时，会将事先创建好的请求对象(request)和响应对象(response)作为参 数进行传递。在servlet内部，可以通过request获得请求数据，或者通过response设置响 应数据。 服务器从response中获取数据，按照http协议打成一个数据包(响应数据包),发送给浏览器。 浏览器会解析响应数据包，取出相应的数据，生成相应的界面。 常见的问题 状态码(表示的是服务器处理请求的一种状态) 404 表示的就是服务器依据请求地址找不到相应的资源 产生的原因： 1.没有部署该应用 2.在 web.xml文件中定义的&lt;servlet-name&gt;不一致 3.请求地址写错了 检查 http://ip:port/appname/url-pattern 500 含义：系统出错 产生原因：通常是程序在运行中出错 1.java类书写问题 2.&lt;servlet-class&gt;写错了 3.代码写的不够严谨，比如对请求参数没有做检查就做一些转化 什么是请求参数？ 在浏览器上输入：http://localhost:8080/webday01/hello?qty=100 qty:请求参数名 100:请求参数值 405 含义：找不到处理方法 原因：service方法定义错误 ###http协议 什么是http协议？是由w3c制定的一种网络应用层协议，规定了浏览器与web服务器之间如何通信以及相应的数据包的格式。 如何通信的 1.建立连接 2.发送请求 3.发送响应 4.关闭连接 特点：一次请求，一次连接 *这样做的优点是：服务器可以利用有限的连接为尽可能多的请求服务 - 数据包的结构 请求数据包 请求行（请求方式 请求资源路径 协议类型和版本） 消息头（是一些键值对 使用“：”隔开），表示特定的含义 实体内容 只有当请求方式为post时，实体内容才会有数据 响应数据包 状态行 （协议类型和版本 状态码 状态描述） 200 正确 500 系统出错 404 找不到对应的资源 消息头 （键值对 比如：content-type 告诉浏览器，服务器返回的数据类型） 实体内容 程序的处理结果，浏览器会解析其中的数据，生成相应的页面 - 两种请求方式 get: 1.哪些情况下会使用到get请求 直接输入某个地址 点击链接 表单默认提交数据的方式 2.特点：将请求参数放在请求资源路径的后面，只能提交少量的数据，会泄露信息不安全 比如路由器就会记录了包含了请求参数的请求地址 post: 1.哪些情况下会使用到post请求？ 设置表单的属性 2.特点： 1.会将请求参数添加到尸体内容里，可以提交大量的数据 2.不会讲请求参数显示在浏览器地址栏，相对安全 注意：不会将请求参数加密 编码问题 服务器端返回的数据的编码问题 response.setContentType(&quot;text/html;charset=utf-8&quot;); out.println()方法在默认情况下会采用”iso..”来编码 表单含有中文参数值 表单提交为什么有乱码？ 表单提交时，浏览器会对表单中的中文参数值进行编码 会按照打开该表单所在的页面时的字符集来编码 而服务器端默认情况下会使用“iso-8859-1”来解码 如何解决？ 1.在html文件里面加上 &lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html;charset=utf-8&quot; &gt;&lt;meta charset=&quot;utf-8&quot;&gt; 服务端使用对应的字符集来解码request.setCharacterEncoding(“utf-8”); //必须保证表单是post请求 使用jdbc访问数据库 需要将jbdc驱动（jar文件）拷贝到web-inf\lib下 使用jdbc提供的一套api来访问数据库 重定向的使用 含义：服务器通知浏览器向一个新的地址发送请求*注： 服务器向浏览器发送一个302状态码和一个location消息头 （该消息头包含了一个地址，称之为重定向地址），浏览器 收到之后立即向地址发送请求。* 如何重定向？ response.sedRedirect(String url);注：url就是重定向地址。重定向之前，容器会清空response对象中保存的数据（out.println()//表示的就是将数据加载到response对象中）2.当重定向代码放置在service方法中 ，服务器会先执行完整个service方法（包括重定向代码后面的代码）然后才会向浏览器发送状态码和 location消息头 重定向的特点： 冲顶向的url是任意的 重定向之后，浏览器地址栏的地址会变 servlet组成及其mvc的覆盖 关于mysql的中文支持问题 mysql的某些驱动，默认会使用iso08859来编码，java用的是unicode来编码的，对于有中文就会出现问题解决办法看下图 servlet的生命周期 什么是servlet的周期？ 容器如何去创建servlet对象，如何对其进行初始化处理，如何 调用其方法来处理请求，以及如何销毁该对象的整个过程。 它分几个阶段？ 实例化 什么是实例化？ 容器通过一个线程调用servlet的构造器，创建相应的对象 什么时候实例化？ 情况一.容器收到请求之后 情况二.容器启动后立即创建 *只需要在web.xml文件中加上一个&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;（这个标签里面的参数值要求是一个大于等于0的整数这个整数越小，优先级就越高。（即先创建）* **一般项目当中都是将所有的servlet都设置成&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;虽然这样服务器加载慢，但是一旦服务器接受请求，运行就快多了** 注：容器只会创建一个实例 初始化 什么是初始化？ 容器调用servlet对象的init方法，该方法只会执行一次，作用：给servlet分配资源（分配一个ServletConfig对象） 关于ServletConfig对象的问题 它是当自定义Java类继承了httpservlet，实现过程：将容器传递过来的servletconfig对象保存下来并且提供了一个获取该对象的方法（getServletConfig()）servletconfig对象的作用 我们可以通过它来访问初始化参数 如何实现自己的初始化处理逻辑？ 只需要覆盖 genericserlevt提供的init()方法 初始化参数 1.配置； &lt;init-param&gt; &lt;param-name&gt;company&lt;/param-name&gt; &lt;param-value&gt;zacwong&lt;/param-value&gt; &lt;/init-param&gt; 2.读取： String ServletConfig.getInitParameter(string s )方法 就绪 什么是就绪？ 容器调用servlet的service方法来处理请求 HttpServlet的service方法是如何实现的？ 依据请求类型（get/post）调用相应的doXXX方法（doGet()/doPost()）注：既然这样，我们在写servlet的时候，继承httpservlet然后可以直接覆盖service方法 或者覆盖doGet()和doPost()方法详细见下图 销毁 什么是销毁？ 容器在删除servlet对象之前，会先调用该对象的destroy方法。 该方法只会执行一次。 相关的几个类和接口 Servlet接口 init() service() destroy() GenericServlet抽象类 实现了servlet接口 实现了Servlet接口中的部分方法（init，destroy） HttpServlet抽象类 继承了GenericServlet抽象类,实现了service方法 servlet测试的相关图片 servlet类的示例 servlet类所对应的web.xml配置 服务器对请求的处理 容器如何处理请求资源路径 比如，在浏览器输入HTTP://IP:PORT/WEB01-02/ABC.HTML 容器依据应用名（“/web01-2”）找到应用所在的文件夹 容器默认认为调用的是一个servlet，他会去web.xml中查找有 没有一个和&quot;/abc.html&quot;匹配的servlet 关于容器匹配的问题 精确匹配 /abc.html 通配匹配 /* 也就是 容器会默认处理浏览器发来的任何资源请求路径 后缀匹配 -使用“.”开头，后接多个字符，比如 .java也就是 容器会处理浏览器发来资源请求路径中含有.java的路径 合并多个servlet JSP什么是jsp? 是sun公司制定的一种服务器端动态页面技术规范。JSP其实是一个“.jsp“为后缀的文件，该文件的内容主要是 HTML和少量的java代码，容器会将JSP文件自动转化成一个servlet 然后执行。 怎么创建一个jsp文件？ 创建一个以’.jsp’为后缀的文件 在文件里面添加如下内容： html(css,js):直接写 Java代码： Java代码片段 格式：&lt;% java语句;%&gt; jsp表达式 格式： &lt;%= java表达式 %&gt; jsp声明 &lt;%! 声明一个变量或者一个方法%&gt; （声明的变量或者方法是在jsp转化成servlet类中） 隐藏对象 什么是隐藏对象？ 在jsp文件里面，可以直接使用的对象，如out,request,response,session,application,exception(注意：session对象的使用详见下图) page对象（jsp示例本身，就是servlet对象，用的很少） pageContext对象(页面上下文) 容器会为每一个jsp实例创建一个唯一的符合PageContext接口要求的对象（它跟ServletContext一样具有唯一性和持久性） 作用： 1.绑定数据 setAttribute getAttribute removeAtrribute 注：绑定到pageContext上的数据只有对应的jsp实例能访问 详细看WebText09-2 a5.jsp a6.jsp 2.获得其他的隐藏对象*我们可以通过它在一个java类获取jsp当中的其他隐藏对象* config 就是servletConfig 通过config读取jsp实例初始化参数配置web.xml 详细看 p24 00:30:06 WebText09-2 a7.jsp &lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;jsp-file&gt;/a7.jsp&lt;/jsp-file&gt; //注意这里的格式 &lt;init-param&gt; &lt;param-name&gt;company&lt;/param-name&gt; &lt;param-value&gt;zac&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;/abc.html&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 这里当我们在访问地址下访问abc.html的时候 服务器就会返回 a7.jsp文件 #####指令 什么是指令？ 通知容器，在将Jsp文件转化成servlet类时做出一些额外的处理，比如导包 指令的语法 &lt;%@指令名称 属性=属性值%&gt; 常见的一些指令 page指令 import属性：导包用的 比如&lt;%@page import=&quot;java.util.*&quot;&gt; 中文处理 `contentType=”text/html; charset=utf-8” session 属性： true(缺省) /false ，当值为false时不能在Jsp中使用session隐藏对象 errorPage: 指定一个异常处理页面 isErrorPage: true/false(缺省)，当值为true时，表示这是一个异常处理界面，可以使用exception对象pageEncoding=”utf-8”` include指令告诉容器，在jsp文件转换成servlet类时，将file属性指定的文件的内容插入到该指令所在的位置》比如：&lt;%@include file=&quot;header.jsp&quot;%&gt; taglib指令 用来引入jsp标签 - ##### jsp是如何执行的？ 1. 容器会将jsp文件转换成一个servlet类 HTML（css,js） ----&gt; service方法使用out.write()输出 java代码片段 --&gt; service方法里，照搬 jsp表达式---&gt; serivce方法里，使用 out.print(java表达式)输出 jsp声明 --&gt;给servlet增加新的属性或者方法 2. 容器调用servlet. jsp当中的注释- `&lt;!--内容 --&gt;` - `&lt;%-- 内容--%&gt;` 建议使用第二种注释方式 处理servlet运行时产生的异常 编程式处理 捕获异常 转发信息到错误页面 图示如下 声明式处理（即交给容器处理）系统异常就用它，但是它不灵活 捕获异常 配置异常处理页面 &lt;error-page&gt; &lt;exception-type&gt;javax.servlet.ServletException&lt;/exception-type&gt; &lt; location &gt;/error2.jsp&lt; /location &gt; &lt;/error-page&gt; 写好error2.jsp 图示如下 声明式异常常常用来处理系统异常（异常发生之后不能恢复，比如数据库停止），发生这类一场后，提醒用户稍后重试即可编程式异常（转发的方式）更灵活，可以处理应用异常(比如，用户输入错误的密码)； 转发 定义：一个组件（servlet/jsp）将未完成的处理交给另外一个web组件继续做。比如，一个servlet将处理结果(调用了dao)转发给一个jsp来实现(展示) 如何转发？ 绑定数据到request上 request.setAttribute(String name,Object obj)注：依据绑定名获得绑定值 Object request.getAttribute(String name); 获得转发器 RequestDispatcher rd =request.getReqiestDispatcher(String url); 转发 rd.forward(request,response); 转发的特点 转发之后，浏览器地址访问servlet的地址栏的地址不变 转发地址有限制(必须是在同一个应用) 转发的注意事项 转发之前，不能执行out.close 和out.flush方法 转发之前，会将response当中缓存的数据清空 如果转发和重定向代码后头都有代码那么 重定向：会继续先执行后面的代码 转发：会先执行转发的页面的代码，再回来执行后面的代码 无论是 request.getRequestDispatcher(path).forward(request, response)还是response.sendRedirect,程序都会在执行完该句的情况下继续向下执行,因此在必要的时候应该使用return终止该方法. 区分重定向和转发 转发所涉及的各个web组件可以共享同一个request对象，重定向不可以注： 容器收到请求后，会创建request对象和response对象，当响应发送完毕，容器会删除响应（response）和请求(request)对象.所以说重定向是两次请求 ，转发的话是一次请求 重定向之后，浏览器的地址栏会变，转发不会变。 重定向的地址是任意的，转发的地址必须是同一个应用下 转发是一件事没完成，重定向是一件事情已经做完 关于路径的相关问题 涉及到的内容有：链接地址，表单提交地址，重定向，转发 详细看p10 1：30：00 和p10 1:56:13 如果填写下列路径 &gt; &lt; a href=&quot;&quot;&gt;&lt;/a &gt; &gt; &lt; form action=&quot;&quot;&gt; &gt; response.sendRedirect(&quot;&quot;) &gt; request.getRequestDispatcher(&quot;&quot;) 绝对路径： 以”/“开头的路径 相对路径： 不以”/“开头的路径 如何写绝对路径？ 链接地址，表单提交地址，重定向，从应用名开始写 转发从应用名之后开始写,要使用string request.getContextPath()获取应用名,在web.xml中配置的servelt的url-parttern的路径的根目录是webRoot 相关路径问题文章]]></content>
      <categories>
        <category>学习-javaweb</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown的使用]]></title>
    <url>%2F2019%2F06%2F02%2Fmarkdown%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[关于空格的问题 无论是写入多少个连续的space 或者 Tab 或者 Enter，一般渲染之后都是只会显示一个空格. 如果想要进行硬换行的话需要在上一行写上两个 space 和 Enter就像这样 如果两行文字之间存在一个或者多个空行那么这些空行渲染后只会显示一行空行，如果在书写的时候 两行空开了那么渲染后自动空一行 就像这样 关于段落问题 在所有段落前后空行就是了 例如： 这是段落一 这是段落二 这是段落三 在段落当中我们还可以使用空行 例如： 这是段落一 你懂的 这是段落二 你也懂的 这是段落三 你更懂的 关于分割线不用多说 关于列表不用多说 列表前面要加上# 然后再换行加上*或者 1. 如果有列表的嵌套使用的话在子列表那块要加上Tab键进行缩进 做一件事情 做另外一件事情 第一步吉萨做啥？ 第二步先干吗 做第三件事请 关于文字加粗倾斜的问题格式： **加粗内容**，*倾斜内容*，***倾斜加粗内容*** 关于转义字符 在正常段落中要原样输出以上字符`*_{}#+-.!通常都要在它们前面加上\ 你是谁？你子啊的撒旦拉萨解放路口设计 撒大苏打撒旦撒范德萨讽德诵功返回* 引用块的使用 引用的效果就如本文档中代码和样式示例。在每行行首加‘&gt;’ （同样也可以通过双空格+回车实现多行效果） 这是一则引用每行行尾没有双空格所以会显示为一行引 这也是一则引用但是它是通过双空格加回车实现 的 下面是二级引用的例子效果如下 加入两个&gt;&gt;符号 就成了(三级引用) 回到一级引用 进入二级引用 进入三级引用 2.如果在&gt;符号后头加入过多的空格那么引用当中就会出现代码块 &gt; public stataic void main(String[]args){ &gt; int a = 1; &gt; int b = 4; &gt; System.out.println(a*b); &gt; } 行内代码和代码段落 行内代码(直接使用``) 这里插入一段代码public void static void main(String[]args){...}另外一段代码String s = &#39;菜菜才&#39;; 代码块 直接往上写 但是教程上是用``` ```括起来的 public class TextCookieAsSession extends HttpServlet { public void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { request.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;text/html;charset=utf-8&quot;); PrintWriter out = response.getWriter(); Cookie c = new Cookie(&quot;count&quot;, &quot;1&quot;); c.setMaxAge(60*24); response.addCookie(c); Cookie[] c1 = request.getCookies(); for (Cookie c2 : c1) { if (c2.getName().equals(&quot;count&quot;)) { out.println(&quot;你访问的次数为&quot;+c2.getValue()); Cookie c3 = new Cookie(&quot;count&quot;, &quot;&quot;+(Integer.parseInt(c2.getValue())+1)); response.addCookie(c3); } } } } 链接和图片上百度搜索呀 行内式链接：方括号中是链接问题，方括号后跟紧的的袁扩好内是地址（可以是网络地址或者主机的相对地址），网址后空一格双引号引起来的是title文字。title文字可以不写详见上头百度 表格 表格语法使用 | ：如果 |与其他非空白符号之间最少空一个空格。 表格由行列组成。 不同行之间用Enter分隔（不需要双空格）。 同行之间分隔不同列使用 | 。行首和行尾也可以使用 | 。 同一张表格，各行的列数（单元格数）应该相同。 一个表格的源代码第一行是表头。但填写规则和普通单元格一样。 一个表格源代码第二行不会渲染成一行单元格。它被用来分隔表头和普通单元格。这一行每一个单元格都填写大于等于三个-。 在第二行的单元格还可以控制本列的对其方式。在一串-左侧加:可以左对齐。右侧加右对齐。双侧加居中。 例如(好像没出效果) left-align center-align right-align git status git status git status 还是得使用html标签呀 TablesAreCoolcol 1 isleft-aligned$1600col 2 iscentered$12col 3 isright-aligned$1]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>导航</tag>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的博客]]></title>
    <url>%2F2019%2F06%2F01%2F%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[第一次写博客坑坑坑 个人邮箱1374340498@qq.com]]></content>
  </entry>
</search>
